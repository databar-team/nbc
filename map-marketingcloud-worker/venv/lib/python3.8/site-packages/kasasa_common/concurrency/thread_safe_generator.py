import threading
from typing import Union
from collections.abc import Iterable, Generator


class ThreadSafeGenerator:
    """
    A Generator object that is thread safe. This object will take any iterable or generator and convert it
    into a thread safe generator by providing thread locks for accessing the objects when necessary.

    While this object supports being used as an iterable, only one thread can use it at a time.
    If threading is required, the recommended usage is below. Some things, like the Connection object in this library,
    may return a ThreadSafeGenerator instead of a normal Generator, so it was important to maintain this functionality.

    Example Usage:
        >>> from kasasa_common.concurrency import ThreadSafeGenerator
        >>> example_list = [1, 2, 3, 4, 5]
        >>> thread_safe_generator = ThreadSafeGenerator(example_list)
        >>> # Accessing items from the generator can be done with the next() function. The default is None but can be
        >>> # overridden with another value using next(thread_safe_generator, "desired value")
        >>> item = next(thread_safe_generator)
        >>> while item is not None:
        ...    print(item)
        ...    item = next(thread_safe_generator)
        ...
        1
        2
        3
        4
        5
    """
    def __init__(self, generator: Union[Iterable, Generator]):
        if isinstance(generator, Iterable) and not isinstance(generator, Generator):
            self._generator = self._list_to_generator(generator)
        else:
            self._generator = generator
        self._lock = threading.Lock()

    def __iter__(self):
        """
        __iter__ (i.e. for item in generator) is not thread safe and should only be used by a function that is
        feeding work to other functions. This was provided to maintain single iteration over a generator.
        """
        value = next(self)
        while value is not None:
            yield value
            value = next(self)

    def __next__(self, default=None):
        with self._lock:
            try:
                return next(self._generator, default)
            except StopIteration:
                return default

    @staticmethod
    def _list_to_generator(li):
        # Convert iterable object that isn't a generator into one
        for item in li:
            yield item
