import threading

from pymysql import Connection as PyMySQLConnection
from typing import Callable, List, Mapping, Tuple, Union

from kasasa_common.concurrency import ThreadSafeGenerator
from .database_helpers import _parse_context_attrs
from .records import Record
from kasasa_common.context import DatabaseContext
from kasasa_common import logger


class Connection:
    def __init__(self, context: DatabaseContext = None,  connection: PyMySQLConnection = None,
                 connect_f: Callable = None, **kwargs):
        self._context: DatabaseContext = context
        self.connection: PyMySQLConnection = self._connect(self._context, connect_f, connection, **kwargs)
        self._lock = threading.Lock()

    def __enter__(self):
        return self

    def __exit__(self):
        self.close()

    @staticmethod
    def _connect(context: DatabaseContext = None, connect_f: Callable = None, connection: PyMySQLConnection = None,
                 **kwargs) -> PyMySQLConnection:
        if connection:
            # This allows get_connection to be used with mock connections, allowing for testing of units that call it
            logger.debug('Using connection object received through arguments.')
            return connection
        elif context:
            db_dict = {**_parse_context_attrs(context), **kwargs}
            return connect_f(**db_dict)

    def close(self):
        with self._lock:
            return self._close()

    def _close(self):
        raise NotImplementedError

    def insert(self, table: str, records: List[Record]) -> int:
        """
        Base insert into the provided table of data into fields

        :param table: str table to insert into
        :param records: list of Record objects
        :return: count of rows affected
        """
        with self._lock:
            return self._insert(table, records)

    def _insert(self, table: str, records: List[Record]) -> int:
        raise NotImplementedError

    def insert_with_sql(self, sql: str, sql_args: Union[List, Tuple, Mapping] = None) -> int:
        """
        Insert using the provided sql

        :param sql: str table to insert into
        :param sql_args: dict, list, or tuple used for string formatting during the execute command
        :return: count of rows affected
        """
        if sql_args is None:
            sql_args = dict()
        with self._lock:
            return self._insert_with_sql(sql, sql_args)

    def _insert_with_sql(self, sql: str, sql_args: Union[List, Tuple, Mapping]) -> int:
        raise NotImplementedError

    def upsert(self, table: str, records: List[Record]) -> int:
        """
        Base upsert into the provided table of data into fields

        :param table: str table to insert into
        :param records: list of Record objects
        :return: count of rows affected
        """
        with self._lock:
            return self._upsert(table, records)

    def _upsert(self, table: str, records: List[Record]) -> int:
        raise NotImplementedError

    def update(self, table: str, records: List[Record]) -> int:
        with self._lock:
            return self._update(table, records)

    def _update(self, table: str, records: List[Record]) -> int:
        raise NotImplementedError

    def update_with_sql(self, sql: str, sql_args: dict = dict()):
        with self._lock:
            return self._update_with_sql(sql, sql_args)

    def _update_with_sql(self, sql: str, sql_args: dict) -> int:
        raise NotImplementedError

    def export(self, sql: str, cursor_type: str = "list", batch_size: int = None, sql_args: dict = dict()):
        """
        Execute the provided sql and return results as a list.

        :param sql: str SELECT statement to export
        :param cursor_type: str dictionary or list
        :param batch_size: optional argument to yield a batch generator instead of a singleton
        :param sql_args: dict used for string formatting during the execute command
        :return:
        """
        with self._lock:
            return self._export(sql, cursor_type, batch_size, sql_args)

    def _export(self, sql: str, cursor_type: str, batch_size: int, sql_args: dict) -> List:
        raise NotImplementedError

    def export_as_generator(self, sql: str, cursor_type: str = "list", batch_size: int = None,
                            sql_args: dict = None) -> ThreadSafeGenerator:
        """
        Execute the provided sql and return results as a thread safe generator object.

        Use this if all records from a query are desired.

        :param sql: str SELECT statement to export
        :param cursor_type: str dictionary or list
        :param batch_size: optional argument to yield a batch generator instead of a singleton
        :param sql_args: dict used for string formatting during the execute command
        :return: generator to access results
        """
        return ThreadSafeGenerator(self._export_as_generator(sql, cursor_type, batch_size, sql_args))

    def _export_as_generator(self, sql: str, cursor_type: str, batch_size: int, sql_args: dict):
        raise NotImplementedError

    def open_connection(self):
        """If a connection is closed and needs to be open, this method will do that"""
        return self._open_connection()

    def _open_connection(self):
        raise NotImplementedError
