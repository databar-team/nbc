import os
import re

from typing import List, Generator
from pymysql import Connection, cursors

_NON_WORD_CHARS = re.compile(r'[^a-zA-Z0-9_]')
_FIRST_CAP_RE = re.compile(r'(.)([A-Z0-9][a-z]+)')
_ALL_CAP_RE = re.compile(r'([a-z])([A-Z0-9])')


def get_sql(sql_file_name: str, sql_path: str, replacement_values: dict = None) -> str:
    """
    Given a filename and a path to a sql directory, return sql. If replacement values is provided,
    sql will be formatted with those values prior to return.

    A sql file can use standard {field_name} to allow for replacement values of things that might change.
    e.g. Table names or lists of field names in the table

    :param sql_file_name: Name of the file to be retrieved
    :param sql_path: Full path in which to look for a sql file
    :param replacement_values: dict of values that need to be replaced and the field name in the file to replace
    :return:
    """
    with open(os.path.join(sql_path, sql_file_name)) as sql_file:
        sql = sql_file.read()
    if replacement_values:
        sql = sql.format(**replacement_values)
    return sql


def _parse_context_attrs(context):
    return dict(
        host=context.DATABASE_HOST,
        port=context.DATABASE_PORT,
        user=context.DATABASE_USERNAME,
        database=context.DATABASE_NAME,
        password=context.VAULT_SECRETS.get(context.DATABASE_PASSWORD_KEY, None)
    )


def enclose_field_names_in_backticks(fields: List[str]) -> List[str]:
    """Given a list of field names as strings, return that list with all names surrounded in backticks"""
    if not isinstance(fields, list):
        raise ValueError('enclose_field_names_in_backticks() requires an input of type list')
    new_list = []
    for field in fields:
        field = scrub_sql_name(field)
        new_list.append(''.join(['`', field, '`']))
    return new_list


def is_table_empty(table: str, connection: Connection) -> bool:
    """Simple check to determine if the provided table is empty in the database on the other end of connection"""
    field_alias = 'is_empty'
    sql = f'SELECT (count(1) = 0) as `{field_alias}` FROM `{scrub_sql_name(table)}` LIMIT 1;'
    with connection.cursor(cursors.DictCursor) as cursor:
        cursor.execute(sql)
        result = cursor.fetchone().get(field_alias, 0)
    return bool(result)


def sql_results_generator(connection: Connection, sql_script_name: str, sql_path: str,
                          sql_args: dict = dict()) -> Generator:
    """
    Returns the results of a sql execution as a generator one row at a time. This is useful for situation where many
    rows are expected and we want to buffer them to prevent overloading memory.

    :param connection: Database connection to run the sql against
    :param sql_script_name: Name of the sql file to run
    :param sql_path: Path on the file system to the location of the sql file
    :param sql_args: Dictionary of any arguments to pass to cursor.execute
    :return: Generator of results from DB
    """
    sql = get_sql(sql_script_name, sql_path=sql_path)
    with connection.cursor(cursors.SSDictCursor) as cursor:
        cursor.execute(sql, args=sql_args)
        row = cursor.fetchone()
        while row:
            yield row
            row = cursor.fetchone()


def scrub_sql_name(name: str) -> str:
    """Scrubs non-word characters from a string and returns the scrubbed string."""
    if type(name) != str:
        return ''

    cleaned = re.sub(_NON_WORD_CHARS, '', name)
    return cleaned
