from typing import List, Generator, Union, Tuple, Mapping

from pymysql import cursors, Connection as PyMySQLConnection

from .records import Record
from .connection import Connection
from kasasa_common.logger import logger
from kasasa_common.context import DatabaseContext


class MySQLConnection(Connection):
    def __init__(self, context: DatabaseContext = None, connection: PyMySQLConnection = None, **kwargs):
        super(MySQLConnection, self).__init__(
            context=context,
            connection=connection,
            connect_f=self._get_mysql_connection,
            **kwargs
        )

    @staticmethod
    def _get_mysql_connection(dict_cursor=False, unbuffered=False, **kwargs):
        """
        Obtain `pymysql.Connection <pymysql.connections.Connection>` instance
        for given DB url.

        :param bool dict_cursor: use `~pymysql.cursors.DictCursor` for cursors,
            so that cursor will return records as dicts rather than tuples.
            Shorthand for `cursorclass=pymysql.cursors.DictCursor`.

        :param bool unbuffered:
            use `~pymysql.cursors.SSCursor`
            which does not buffer all response data in memory.
            The downside is that it cannot report number of records
            and navigate them only forwards.
            This option can be combined with ``dict_cursor``
            which will result in `~pymysql.cursors.SSDictCursor`.

        :param kwargs: additional attributes to pass to `pymysql`.
            Common examples are ``password`` or ``database``.
        """
        import pymysql
        logger.info('Obtaining database connection...')

        params = dict()
        params['cursorclass'] = getattr(pymysql.cursors, '{}{}Cursor'.format(
            'SS' if unbuffered else '',
            'Dict' if dict_cursor else '',
        ))
        params.update(kwargs)

        if not all(params.get(k) for k in ('host', 'user', 'password')):
            raise ValueError('Host, user and password are mandatory and should be provided in kwargs')

        print_params = params.copy()
        print_params['password'] = '<redacted>'

        logger.debug('Connecting to DB using these credentials (password masked): %s', print_params)
        conn = pymysql.connect(**params)
        logger.debug('Obtained DB connection: %s', conn)

        return conn

    def _close(self):
        if self.connection.open:
            return self.connection.close()

    @property
    def _base_insert_sql(self):
        return "INSERT INTO {table} ({fields}) VALUES {multi_values}"

    @property
    def _update_on_duplicate_sql(self):
        return "ON DUPLICATE KEY UPDATE {fields}"

    def _insert(self, table: str, records: List[Record], **_) -> int:
        """
        Base insert into the provided table of data into fields

        :param table: str table to insert into
        :param records: list of Record objects
        :return: count of rows affected
        """
        self._open_connection()
        count = 0
        try:
            sql = self._format_base_insert(table, records) + ";"
        except ValueError as ve:
            logger.debug(ve)
            return count
        logger.debug(f"Preformatted SQL: {sql}")
        with self.connection.cursor() as cursor:
            count += cursor.execute(sql)
            self.connection.commit()
        return count

    def _insert_with_sql(self, sql: str, sql_args: Union[List, Tuple, Mapping], **_) -> int:
        """
        Insert using the provided sql

        :param sql: str table to insert into
        :param sql_args: dict used for string formatting during the execute command
        :return: count of rows affected
        """
        self._open_connection()
        count = 0
        with self.connection.cursor() as cursor:
            count += cursor.execute(sql, args=sql_args)
            self.connection.commit()
        return count

    def _upsert(self, table: str, records: List[Record], **_) -> int:
        """
        Base upsert into the provided table of data into fields

        :param table: str table to insert into
        :param records: list of Record objects
        :return: count of rows affected
        """
        self._open_connection()
        count = 0
        try:
            sql = self._format_base_insert(table, records)
            sql += self._format_on_duplicate_update(records[0].field_list)
        except ValueError as ve:
            logger.debug(ve)
            return count
        logger.debug(f"Preformatted SQL: {self._base_insert_sql}")
        with self.connection.cursor() as cursor:
            count += cursor.execute(sql)
            self.connection.commit()
        return count

    def _update(self, table: str, records: List[Record], **_) -> int:
        pass

    def _update_with_sql(self, sql: str, sql_args: dict, **_) -> int:
        pass

    def _export(self, sql: str, cursor_type: str, batch_size: int, sql_args: dict, **_) -> List:
        """
        Execute the provided sql and return results as a list.

        :param sql: str SELECT statement to export
        :param cursor_type: str dictionary or list
        :param batch_size: optional argument to yield a batch generator instead of a singleton
        :param sql_args: dict used for string formatting during the execute command
        :return:
        """
        self._open_connection()
        logger.debug('Exporting from DB')
        with self.connection.cursor() as cursor:
            cursor.execute(sql, args=sql_args)
            if batch_size:
                result = cursor.fetchmany(size=batch_size)
            else:
                result = cursor.fetchall()
            if len(result) == 0:
                raise ValueError("No results exported!")
        return result

    def _export_as_generator(self, sql: str, cursor_type: str, batch_size: int, sql_args: dict, **_) -> Generator:
        """
        Execute the provided sql and return results as a generator.

        Use this if all records are desired.

        :param sql: str SELECT statement to export
        :param cursor_type: str dictionary or list
        :param batch_size: optional argument to yield a batch generator instead of a singleton
        :param sql_args: dict used for string formatting during the execute command
        :return: generator to access results
        """
        self._open_connection()
        cursor_obj = dict(
            dictionary=cursors.SSDictCursor,
            list=cursors.SSCursor
        ).get(cursor_type, cursors.SSCursor)
        with self.connection.cursor(cursor_obj) as cursor:
            logger.debug("Executing: {sql}".format(sql=sql))
            cursor.execute(sql)
            fetch = self._get_fetch_method(cursor, batch_size)
            while True:
                batch = fetch()
                if not batch:
                    break
                yield batch

    @staticmethod
    def _get_fetch_method(cursor, batch_size, **_):
        # returns a prepared function based on if we want a larger batch
        # this prevents having to do a check every iteration
        def fetch_many_wrapper():
            # fetchmany returns the batch in a list
            return cursor.fetchmany(batch_size)

        def fetch_one_wrapper():
            # fetchone returns a single item
            return cursor.fetchone()

        if batch_size and batch_size > 1:
            return fetch_many_wrapper
        else:
            return fetch_one_wrapper

    def _format_base_insert(self, table: str, records: List[Record], **_) -> str:
        values = self._format_records(records)
        return self._base_insert_sql.format(
            table=table,
            fields=records[0].field_list_for_sql,
            multi_values=values
        )

    def _format_on_duplicate_update(self, fields, **_):
        return self._update_on_duplicate_sql.format(
            fields=f"{', '.join([f'`{field}` = VALUES(`{field}`)' for field in fields])};"
        )

    @staticmethod
    def _format_records(records: List[Record], **_) -> str:
        values = ""
        for i, record in enumerate(records):
            values += record.as_string + ", "
        if values == "":
            raise ValueError("No records found")
        return values[:-2]  # strip extra ", " from the end

    def _open_connection(self):
        if not self.connection.open:
            self.connection.connect()
